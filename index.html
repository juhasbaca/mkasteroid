<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASTEROIDS - Retro Space Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0e27;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
        }

        #gameCanvas {
            border: 2px solid #7209b7;
            box-shadow: 0 0 20px rgba(114, 9, 183, 0.5);
            display: block;
            max-width: 100%;
            max-height: 100vh;
            width: auto;
            height: auto;
        }

        /* Mobile-specific adjustments */
        @media (max-width: 768px) {
            #gameCanvas {
                max-width: 100vw;
                max-height: 100vh;
                width: 100vw !important;
                height: auto !important;
            }

            body {
                overflow: hidden;
                touch-action: none;
            }
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .social-links {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 14px;
            color: #8b8b8b;
            z-index: 100;
        }

        .social-links a {
            color: #00ff41;
            text-decoration: none;
            margin: 0 8px;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
        }

        .social-links a:hover {
            color: #00d9ff;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.8);
            transform: scale(1.1);
        }

        .social-links .divider {
            color: #8b8b8b;
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="social-links">
        Created with Claude Code (vibe coding) by © Marcin Krupiński
        <span class="divider">•</span>
        <a href="https://www.tiktok.com/@ai.marcin" target="_blank" rel="noopener">TikTok</a>
        <span class="divider">•</span>
        <a href="https://www.instagram.com/krupinskiai" target="_blank" rel="noopener">Instagram</a>
    </div>

    <script>
        // ============================================================
        // GAME CONFIGURATION
        // ============================================================

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size - responsive for mobile portrait and landscape
        const isMobilePortrait = window.innerHeight > window.innerWidth;
        if (isMobilePortrait) {
            // Portrait mode: use full width, maintain reasonable aspect ratio
            canvas.width = window.innerWidth;
            canvas.height = Math.min(window.innerHeight, canvas.width * 1.5); // Max 1.5:1 ratio
        } else {
            // Landscape/Desktop: use standard sizing
            canvas.width = Math.min(window.innerWidth - 20, 1200);
            canvas.height = Math.min(window.innerHeight - 20, 800);
        }

        // Performance optimization: Background layer for static elements
        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = canvas.width;
        bgCanvas.height = canvas.height;
        const bgCtx = bgCanvas.getContext('2d');
        let bgNeedsRedraw = true;
        let bgUpdateTimer = 0;
        const BG_UPDATE_INTERVAL = 2; // Update background every 2 seconds for star twinkle

        // Game version
        const VERSION = 'v1.2.0';

        // Performance limits
        const MAX_ASTEROIDS = 40; // Aggressive optimization: limit total asteroids

        // Game states
        const GAME_STATE = {
            START: 'start',
            PLAYING: 'playing',
            PAUSED: 'paused',
            GAME_OVER: 'gameOver',
            WAVE_TRANSITION: 'waveTransition',
            HELP: 'help'
        };

        // Difficulty settings
        const DIFFICULTY = {
            EASY: {
                name: 'EASY',
                asteroidSpeed: 0.6,
                ufoAccuracy: 0.6,
                ufoSpawnMin: 25000,
                ufoSpawnMax: 30000,
                lives: 4,
                powerupChance: 0.5  // Zwiększone z 0.3 do 0.5 (50%)
            },
            MEDIUM: {
                name: 'MEDIUM',
                asteroidSpeed: 1.0,
                ufoAccuracy: 0.75,
                ufoSpawnMin: 18000,
                ufoSpawnMax: 25000,
                lives: 3,
                powerupChance: 0.4  // Zwiększone z 0.2 do 0.4 (40%)
            },
            HARD: {
                name: 'HARD',
                asteroidSpeed: 1.5,
                ufoAccuracy: 0.9,
                ufoSpawnMin: 12000,
                ufoSpawnMax: 18000,
                lives: 2,
                powerupChance: 0.35,  // Zwiększone z 0.15 do 0.35 (35%)
                shipTurnSpeed: 1.3
            }
        };

        // ============================================================
        // GAME STATE
        // ============================================================

        let gameState = GAME_STATE.START;
        let previousGameState = GAME_STATE.START;
        let selectedDifficulty = DIFFICULTY.MEDIUM;
        let score = 0;
        let highScore = parseInt(localStorage.getItem('asteroidsHighScore')) || 0;
        let lives = 3;
        let wave = 1;
        let currentWaveType = 'normal'; // Wave variety feature
        let comboCount = 0;
        let comboTimer = 0;
        let comboMultiplier = 1;
        let lastKillTime = 0;
        let shotsFired = 0;
        let shotsHit = 0;
        let asteroidsDestroyed = 0;
        let ufosDestroyed = 0;
        let showTutorial = true;
        let tutorialTimer = 0;
        let muted = false;
        let waveTransitionTimer = 0;
        let waveTransitionMessage = '';

        // Achievements system
        let achievements = {
            firstBlood: { unlocked: false, name: 'First Blood', desc: 'Destroy your first asteroid' },
            comboMaster: { unlocked: false, name: 'Combo Master', desc: 'Reach 5x combo multiplier' },
            wave5: { unlocked: false, name: 'Survivor', desc: 'Reach wave 5' },
            wave10: { unlocked: false, name: 'Veteran', desc: 'Reach wave 10' },
            sharpShooter: { unlocked: false, name: 'Sharp Shooter', desc: '80%+ accuracy (20+ shots)' },
            ufoHunter: { unlocked: false, name: 'UFO Hunter', desc: 'Destroy 5 UFOs' },
            collector: { unlocked: false, name: 'Collector', desc: 'Collect 10 power-ups' },
            bomberman: { unlocked: false, name: 'Bomberman', desc: 'Use a bomb power-up' }
        };
        let unlockedAchievements = JSON.parse(localStorage.getItem('asteroidsAchievements') || '{}');
        Object.keys(unlockedAchievements).forEach(key => {
            if (achievements[key]) achievements[key].unlocked = true;
        });
        let achievementPopup = null; // {name, desc, timer}
        let powerupsCollected = 0;

        // Input state
        const keys = {};
        let mouseX = canvas.width / 2;  // Initialize to center to prevent ship going crazy
        let mouseY = canvas.height / 2;
        let mouseDown = false;
        let useMouseControls = false; // Toggle with 'C' key
        let touchX = canvas.width / 2;  // Initialize to center
        let touchY = canvas.height / 2;
        let touching = false;
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Audio context
        let audioContext = null;

        // Objects
        let ship = null;
        let asteroids = [];
        let bullets = [];
        let ufoBullets = [];
        let ufo = null;
        let powerups = [];
        let scorePopups = [];

        // Background elements
        let stars = [];
        let shootingStars = [];
        let nextShootingStarTime = 0;

        // Visual effects
        let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
        let flashEffect = { active: false, color: '#ffffff', alpha: 0 };
        let borderGlow = { active: false, color: '#ffffff', intensity: 0, duration: 0 };
        let muteIndicatorAlpha = 0;
        let controlModeIndicatorAlpha = 0;
        let impactSparks = [];
        let currentTime = 0; // Cached time for animations (performance optimization)

        // Timers
        let ufoSpawnTimer = 0;
        let nextUfoSpawnTime = 20000;

        // Power-up states
        let activePowerups = {
            shield: false,
            tripleShot: { active: false, timer: 0 },
            rapidFire: { active: false, timer: 0 },
            magnet: { active: false, timer: 0 },
            slowMo: { active: false, timer: 0 }
        };
        let timeScale = 1.0; // For slow-mo effect

        // ============================================================
        // UTILITY FUNCTIONS
        // ============================================================

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomInt(min, max) {
            return Math.floor(random(min, max + 1));
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function wrap(value, min, max) {
            if (value < min) return max;
            if (value > max) return min;
            return value;
        }

        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        // ============================================================
        // AUDIO SYSTEM
        // ============================================================

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (muted || !audioContext) return;

            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();

            osc.connect(gain);
            gain.connect(audioContext.destination);

            switch(type) {
                case 'shoot':
                    osc.frequency.setValueAtTime(800, now);
                    osc.frequency.exponentialRampToValueAtTime(400, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;

                case 'thrust':
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(50, now);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                    break;

                case 'asteroidSmall':
                    osc.frequency.setValueAtTime(300, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                    break;

                case 'asteroidMedium':
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.exponentialRampToValueAtTime(40, now + 0.4);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                    osc.start(now);
                    osc.stop(now + 0.4);
                    break;

                case 'asteroidLarge':
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
                    gain.gain.setValueAtTime(0.25, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;

                case 'ufoShoot':
                    osc.frequency.setValueAtTime(600, now);
                    osc.frequency.exponentialRampToValueAtTime(200, now + 0.15);
                    gain.gain.setValueAtTime(0.12, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(now);
                    osc.stop(now + 0.15);
                    break;

                case 'ufoDestroy':
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
                    gain.gain.setValueAtTime(0.2, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                    break;

                case 'powerup':
                    [400, 500, 600, 800].forEach((freq, i) => {
                        const o = audioContext.createOscillator();
                        const g = audioContext.createGain();
                        o.connect(g);
                        g.connect(audioContext.destination);
                        o.frequency.value = freq;
                        g.gain.setValueAtTime(0.1, now + i * 0.05);
                        g.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.1);
                        o.start(now + i * 0.05);
                        o.stop(now + i * 0.05 + 0.1);
                    });
                    return;

                case 'death':
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.exponentialRampToValueAtTime(50, now + 0.8);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    osc.start(now);
                    osc.stop(now + 0.8);
                    break;

                case 'combo':
                    const pitch = 400 + comboMultiplier * 100;
                    osc.frequency.setValueAtTime(pitch, now);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                    osc.start(now);
                    osc.stop(now + 0.2);
                    break;
            }
        }

        // ============================================================
        // PARTICLE SYSTEM
        // ============================================================

        class Particle {
            constructor(x, y, vx, vy, color, size, life) {
                this.reset(x, y, vx, vy, color, size, life);
            }

            reset(x, y, vx, vy, color, size, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.size = size;
                this.life = life;
                this.maxLife = life;
                this.rotation = random(0, Math.PI * 2);
                this.rotationSpeed = random(-0.2, 0.2);
                this.active = true;
            }

            update(dt) {
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.life -= dt;
                this.rotation += this.rotationSpeed;
                this.vx *= 0.99;
                this.vy *= 0.99;
                if (this.life <= 0) this.active = false;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                ctx.restore();
            }
        }

        // Performance: Object pool for particles (reduces GC pressure)
        class ParticlePool {
            constructor(size) {
                this.pool = [];
                for (let i = 0; i < size; i++) {
                    this.pool.push(new Particle(0, 0, 0, 0, '#fff', 1, 0));
                }
                this.pool.forEach(p => p.active = false);
            }

            get(x, y, vx, vy, color, size, life) {
                // Find inactive particle
                let particle = this.pool.find(p => !p.active);
                if (particle) {
                    particle.reset(x, y, vx, vy, color, size, life);
                    return particle;
                }
                // Pool exhausted, create new (shouldn't happen often)
                particle = new Particle(x, y, vx, vy, color, size, life);
                this.pool.push(particle);
                return particle;
            }

            getActiveParticles() {
                return this.pool.filter(p => p.active);
            }
        }

        const particlePool = new ParticlePool(500);

        function createExplosion(x, y, count, colors, speedMult = 1) {
            // Performance: Use object pool instead of creating new particles
            for (let i = 0; i < count; i++) {
                const angle = random(0, Math.PI * 2);
                const speed = random(1, 4) * speedMult;
                const color = colors[randomInt(0, colors.length - 1)];
                particlePool.get(
                    x, y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    color,
                    random(2, 5),
                    random(0.5, 1.5)
                );
            }
        }

        // ============================================================
        // SCREEN EFFECTS
        // ============================================================

        function addScreenShake(intensity, duration) {
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
            screenShake.duration = Math.max(screenShake.duration, duration);
        }

        function updateScreenShake(dt) {
            if (screenShake.duration > 0) {
                screenShake.duration -= dt;
                const progress = screenShake.duration / 0.4;
                const currentIntensity = screenShake.intensity * progress;
                screenShake.x = random(-currentIntensity, currentIntensity);
                screenShake.y = random(-currentIntensity, currentIntensity);
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
            }
        }

        function addFlash(color, alpha = 0.5) {
            flashEffect.active = true;
            flashEffect.color = color;
            flashEffect.alpha = alpha;
        }

        function updateFlash(dt) {
            if (flashEffect.active) {
                flashEffect.alpha -= dt * 2;
                if (flashEffect.alpha <= 0) {
                    flashEffect.active = false;
                }
            }
        }

        function addBorderGlow(color, intensity = 1, duration = 0.5) {
            borderGlow.active = true;
            borderGlow.color = color;
            borderGlow.intensity = Math.max(borderGlow.intensity, intensity);
            borderGlow.duration = Math.max(borderGlow.duration, duration);
        }

        function updateBorderGlow(dt) {
            if (borderGlow.duration > 0) {
                borderGlow.duration -= dt;
                if (borderGlow.duration <= 0) {
                    borderGlow.active = false;
                    borderGlow.intensity = 0;
                }
            }
        }

        // Impact sparks for asteroid hits
        class ImpactSpark {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * random(3, 6);
                this.vy = Math.sin(angle) * random(3, 6);
                this.life = random(0.3, 0.6);
                this.maxLife = this.life;
                this.color = ['#ffff00', '#ff9933', '#ffffff'][randomInt(0, 2)];
                this.size = random(2, 4);
            }

            update(dt) {
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.life -= dt;
                this.vx *= 0.95;
                this.vy *= 0.95;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function createImpactSparks(x, y, angle, count = 5) {
            for (let i = 0; i < count; i++) {
                const spreadAngle = angle + random(-0.5, 0.5);
                impactSparks.push(new ImpactSpark(x, y, spreadAngle));
            }
        }

        // ============================================================
        // SCORE POPUP
        // ============================================================

        class ScorePopup {
            constructor(x, y, text, color = '#00ff41') {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 1.5;
                this.vy = -2;
            }

            update(dt) {
                this.y += this.vy * dt * 60;
                this.life -= dt;
            }

            draw() {
                const alpha = Math.min(1, this.life);
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.font = 'bold 20px Courier New';
                ctx.fillStyle = this.color;
                ctx.textAlign = 'center';
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }
        }

        function addScorePopup(x, y, points) {
            const color = comboMultiplier > 1 ? '#ff00ff' : '#00ff41';
            const text = `+${points}`;
            scorePopups.push(new ScorePopup(x, y, text, color));
        }

        function unlockAchievement(key) {
            if (achievements[key] && !achievements[key].unlocked) {
                achievements[key].unlocked = true;
                unlockedAchievements[key] = true;
                localStorage.setItem('asteroidsAchievements', JSON.stringify(unlockedAchievements));
                achievementPopup = { name: achievements[key].name, desc: achievements[key].desc, timer: 4 };
                playSound('powerup');
                addFlash('#ffd700', 0.4);
            }
        }

        function checkAchievements() {
            if (asteroidsDestroyed >= 1) unlockAchievement('firstBlood');
            if (comboMultiplier >= 5) unlockAchievement('comboMaster');
            if (wave >= 5) unlockAchievement('wave5');
            if (wave >= 10) unlockAchievement('wave10');
            if (shotsFired >= 20 && shotsHit / shotsFired >= 0.8) unlockAchievement('sharpShooter');
            if (ufosDestroyed >= 5) unlockAchievement('ufoHunter');
            if (powerupsCollected >= 10) unlockAchievement('collector');
        }

        // ============================================================
        // SHIP
        // ============================================================

        class Ship {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height / 2;
                this.vx = 0;
                this.vy = 0;
                this.angle = -Math.PI / 2;
                this.radius = 15;
                this.thrust = false;
                this.invulnerable = true;
                this.invulnerableTime = 2.5;
                this.shootCooldown = 0;
                this.thrustFrame = 0;
            }

            update(dt) {
                // Touch controls (mobile only)
                if (touching) {
                    // Calculate angle to touch position
                    const dx = touchX - this.x;
                    const dy = touchY - this.y;
                    const targetAngle = Math.atan2(dy, dx);

                    // Smoothly rotate toward target
                    let angleDiff = targetAngle - this.angle;
                    // Normalize angle difference to -PI to PI
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    // Apply rotation (faster turn for touch)
                    const turnSpeed = 0.15;
                    if (Math.abs(angleDiff) > 0.1) {
                        this.angle += angleDiff * turnSpeed;
                    }

                    // Auto-thrust toward touch (with dead zone)
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    this.thrust = distance > 50; // 50px dead zone

                    if (this.thrust) {
                        const acceleration = 0.3;
                        this.vx += Math.cos(this.angle) * acceleration;
                        this.vy += Math.sin(this.angle) * acceleration;
                        this.thrustFrame = (this.thrustFrame + 0.2) % 3;
                    }

                    // Auto-shoot when touching
                    this.shoot();
                } else {
                    // Keyboard controls
                    const turnSpeed = (selectedDifficulty.shipTurnSpeed || 1) * 5 * (Math.PI / 180);
                    if (keys.ArrowLeft) this.angle -= turnSpeed;
                    if (keys.ArrowRight) this.angle += turnSpeed;

                    // Thrust
                    this.thrust = keys.ArrowUp;
                }

                // Apply thrust physics for keyboard mode
                if (this.thrust && !touching) {
                    const acceleration = 0.3;
                    this.vx += Math.cos(this.angle) * acceleration;
                    this.vy += Math.sin(this.angle) * acceleration;
                    this.thrustFrame = (this.thrustFrame + 0.2) % 3;
                }

                // Enhanced thrust particles for both control modes
                if (this.thrust && Math.random() < 0.3) {
                    const tailX = this.x - Math.cos(this.angle) * 20;
                    const tailY = this.y - Math.sin(this.angle) * 20;
                    const angleSpread = random(-0.3, 0.3);
                    const particleAngle = this.angle + Math.PI + angleSpread;
                    const speed = random(1, 3);
                    particlePool.get(
                        tailX, tailY,
                        Math.cos(particleAngle) * speed + this.vx * 0.3,
                        Math.sin(particleAngle) * speed + this.vy * 0.3,
                        ['#ff9933', '#ff6633', '#ffcc33', '#ffaa00', '#ffffff'][randomInt(0, 4)],
                        random(2, 5),
                        random(0.3, 0.7)
                    );
                }

                // Drag
                this.vx *= 0.99;
                this.vy *= 0.99;

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Wrap around screen
                this.x = wrap(this.x, 0, canvas.width);
                this.y = wrap(this.y, 0, canvas.height);

                // Shoot cooldown
                if (this.shootCooldown > 0) {
                    this.shootCooldown -= dt;
                }

                // Invulnerability
                if (this.invulnerable) {
                    this.invulnerableTime -= dt;
                    if (this.invulnerableTime <= 0) {
                        this.invulnerable = false;
                    }
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Flash when invulnerable
                if (this.invulnerable) {
                    ctx.globalAlpha = Math.sin(currentTime / 100) * 0.5 + 0.5;
                }

                // Shield effect
                if (activePowerups.shield) {
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#3b82f6';
                    const shieldRotation = currentTime / 500;
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 + shieldRotation;
                        const x1 = Math.cos(angle) * 25;
                        const y1 = Math.sin(angle) * 25;
                        const angle2 = ((i + 1) / 6) * Math.PI * 2 + shieldRotation;
                        const x2 = Math.cos(angle2) * 25;
                        const y2 = Math.sin(angle2) * 25;
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }

                // Ship body - much cooler design!
                ctx.strokeStyle = '#00ff41';
                ctx.fillStyle = '#00ff41';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00ff41';

                // Main fuselage
                ctx.beginPath();
                ctx.moveTo(18, 0);
                ctx.lineTo(12, -3);
                ctx.lineTo(-8, -3);
                ctx.lineTo(-10, -5);
                ctx.lineTo(-10, 5);
                ctx.lineTo(-8, 3);
                ctx.lineTo(12, 3);
                ctx.closePath();
                ctx.stroke();
                ctx.globalAlpha = 0.3;
                ctx.fill();
                ctx.globalAlpha = 1;

                // Wings
                ctx.beginPath();
                ctx.moveTo(-8, -3);
                ctx.lineTo(-4, -10);
                ctx.lineTo(4, -6);
                ctx.lineTo(-8, -3);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(-8, 3);
                ctx.lineTo(-4, 10);
                ctx.lineTo(4, 6);
                ctx.lineTo(-8, 3);
                ctx.stroke();

                // Cockpit window
                ctx.strokeStyle = '#00d9ff';
                ctx.fillStyle = '#00d9ff';
                ctx.shadowColor = '#00d9ff';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(10, 0);
                ctx.lineTo(6, -2);
                ctx.lineTo(6, 2);
                ctx.closePath();
                ctx.stroke();
                ctx.globalAlpha = 0.6;
                ctx.fill();
                ctx.globalAlpha = 1;

                // Engine details
                ctx.strokeStyle = '#ff9933';
                ctx.lineWidth = 1.5;
                ctx.shadowColor = '#ff9933';
                ctx.beginPath();
                ctx.moveTo(-10, -5);
                ctx.lineTo(-13, -5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-10, 5);
                ctx.lineTo(-13, 5);
                ctx.stroke();

                // Accent lines
                ctx.strokeStyle = '#00ff41';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.lineTo(0, 0);
                ctx.stroke();

                // Thrust flame
                if (this.thrust) {
                    const flameLength = [12, 15, 10][Math.floor(this.thrustFrame)];
                    ctx.fillStyle = '#ff9933';
                    ctx.shadowColor = '#ff9933';
                    ctx.beginPath();
                    ctx.moveTo(-5, -3);
                    ctx.lineTo(-5 - flameLength, 0);
                    ctx.lineTo(-5, 3);
                    ctx.closePath();
                    ctx.fill();
                }

                // Shoot cooldown indicator - flash when ready
                if (this.shootCooldown <= 0 && currentTime % 1000 < 500) {
                    ctx.strokeStyle = '#00d9ff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#00d9ff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 22, 0, Math.PI * 2);
                    ctx.globalAlpha = 0.3;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                // Combo multiplier visual
                if (comboMultiplier > 1) {
                    ctx.font = 'bold 16px Courier New';
                    const comboColor = comboMultiplier <= 3 ? '#00ffff' : comboMultiplier <= 6 ? '#ff00ff' : '#ff0000';
                    ctx.fillStyle = comboColor;
                    ctx.strokeStyle = comboColor;
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = comboColor;
                    const pulse = Math.sin(currentTime / 100) * 0.2 + 1;
                    ctx.globalAlpha = pulse * 0.8;
                    ctx.fillText(`×${comboMultiplier}`, 0, -30);
                    ctx.globalAlpha = 1;
                }

                ctx.restore();
            }

            shoot() {
                if (this.shootCooldown > 0) return;

                const fireRate = activePowerups.rapidFire.active ? 0.067 : 0.2;
                this.shootCooldown = fireRate;

                playSound('shoot');
                shotsFired++;

                if (activePowerups.tripleShot.active) {
                    // Triple shot
                    [-0.3, 0, 0.3].forEach(angleOffset => {
                        const angle = this.angle + angleOffset;
                        bullets.push(new Bullet(
                            this.x + Math.cos(angle) * 20,
                            this.y + Math.sin(angle) * 20,
                            Math.cos(angle) * 10 + this.vx,
                            Math.sin(angle) * 10 + this.vy
                        ));
                    });
                } else {
                    // Single shot
                    bullets.push(new Bullet(
                        this.x + Math.cos(this.angle) * 20,
                        this.y + Math.sin(this.angle) * 20,
                        Math.cos(this.angle) * 10 + this.vx,
                        Math.sin(this.angle) * 10 + this.vy
                    ));
                }
            }
        }

        // ============================================================
        // BULLET
        // ============================================================

        class Bullet {
            constructor(x, y, vx, vy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.radius = 3;
                this.life = 2;
                this.trail = [];
            }

            update(dt) {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 5) this.trail.shift();

                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.life -= dt;

                // Remove bullet if it goes off-screen
                if (this.x < -10 || this.x > canvas.width + 10 ||
                    this.y < -10 || this.y > canvas.height + 10) {
                    this.life = 0;
                }
            }

            draw() {
                // Trail
                ctx.strokeStyle = '#00d9ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                this.trail.forEach((point, i) => {
                    ctx.globalAlpha = i / this.trail.length * 0.5;
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();

                // Bullet
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#00d9ff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ============================================================
        // ASTEROID
        // ============================================================

        class Asteroid {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size; // 'large', 'medium', 'small'
                this.radius = size === 'large' ? 40 : size === 'medium' ? 20 : 10;

                const speed = selectedDifficulty.asteroidSpeed * (size === 'large' ? 0.5 : size === 'medium' ? 1 : 1.5);
                const angle = random(0, Math.PI * 2);
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.rotation = 0;
                this.rotationSpeed = random(-0.02, 0.02);

                // Generate random shape (simplified for performance)
                this.points = [];
                const numPoints = 6; // Aggressive optimization: reduced from 8-12 to 6
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2;
                    const radius = this.radius * random(0.8, 1.2);
                    this.points.push({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
                }
            }

            update(dt) {
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.rotation += this.rotationSpeed;

                this.x = wrap(this.x, 0, canvas.width);
                this.y = wrap(this.y, 0, canvas.height);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 2;

                ctx.beginPath();
                this.points.forEach((point, i) => {
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.closePath();
                ctx.stroke();

                ctx.restore();
            }

            split() {
                const newAsteroids = [];
                const count = 2; // Aggressive optimization: always split into 2

                if (this.size === 'large') {
                    for (let i = 0; i < count; i++) {
                        newAsteroids.push(new Asteroid(this.x, this.y, 'medium'));
                    }
                } else if (this.size === 'medium') {
                    for (let i = 0; i < count; i++) {
                        newAsteroids.push(new Asteroid(this.x, this.y, 'small'));
                    }
                }

                return newAsteroids;
            }

            getPoints() {
                return this.size === 'large' ? 20 : this.size === 'medium' ? 50 : 100;
            }
        }

        // ============================================================
        // UFO
        // ============================================================

        class UFO {
            constructor(isSmall) {
                this.isSmall = isSmall;
                this.radius = isSmall ? 15 : 25;

                // Spawn from random edge
                const edge = randomInt(0, 3);
                if (edge === 0) { // top
                    this.x = random(0, canvas.width);
                    this.y = -this.radius;
                } else if (edge === 1) { // right
                    this.x = canvas.width + this.radius;
                    this.y = random(0, canvas.height);
                } else if (edge === 2) { // bottom
                    this.x = random(0, canvas.width);
                    this.y = canvas.height + this.radius;
                } else { // left
                    this.x = -this.radius;
                    this.y = random(0, canvas.height);
                }

                // Move towards opposite side
                const targetX = edge === 1 ? -this.radius : edge === 3 ? canvas.width + this.radius : random(0, canvas.width);
                const targetY = edge === 0 ? canvas.height + this.radius : edge === 2 ? -this.radius : random(0, canvas.height);

                const angle = Math.atan2(targetY - this.y, targetX - this.x);
                const speed = isSmall ? 2 : 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                this.shootTimer = random(1.5, 2);
                this.pulsePhase = 0;
            }

            update(dt) {
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.pulsePhase += dt * 3;

                // Shoot at player
                this.shootTimer -= dt;
                if (this.shootTimer <= 0 && ship) {
                    this.shoot();
                    this.shootTimer = random(1.5, 2);
                }

                // Check if off screen
                if (this.x < -100 || this.x > canvas.width + 100 ||
                    this.y < -100 || this.y > canvas.height + 100) {
                    return false; // Remove UFO
                }

                return true;
            }

            shoot() {
                playSound('ufoShoot');
                addScreenShake(2, 0.1);

                let targetX, targetY;

                if (Math.random() < selectedDifficulty.ufoAccuracy) {
                    // Aim at player
                    targetX = ship.x;
                    targetY = ship.y;
                } else {
                    // Random direction
                    targetX = random(0, canvas.width);
                    targetY = random(0, canvas.height);
                }

                const angle = Math.atan2(targetY - this.y, targetX - this.x);
                const speed = 5;

                ufoBullets.push({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 4,
                    life: 3
                });
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                const pulse = Math.sin(this.pulsePhase) * 0.2 + 1;

                ctx.strokeStyle = '#ff3366';
                ctx.fillStyle = '#ff3366';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 15 * pulse;
                ctx.shadowColor = '#ff3366';

                const size = this.radius;

                // UFO body
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 0.8, size * 0.4, 0, 0, Math.PI * 2);
                ctx.stroke();

                // UFO dome
                ctx.beginPath();
                ctx.ellipse(0, -size * 0.3, size * 0.4, size * 0.3, 0, 0, Math.PI, true);
                ctx.stroke();

                // UFO base
                ctx.beginPath();
                ctx.moveTo(-size * 0.8, 0);
                ctx.lineTo(-size * 1.2, size * 0.3);
                ctx.lineTo(size * 1.2, size * 0.3);
                ctx.lineTo(size * 0.8, 0);
                ctx.stroke();

                // Lights
                ctx.fillStyle = '#ff9933';
                [-0.5, 0, 0.5].forEach(offset => {
                    ctx.beginPath();
                    ctx.arc(offset * size, size * 0.3, 2, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.restore();
            }

            getPoints() {
                return this.isSmall ? 200 : 100;
            }
        }

        // ============================================================
        // POWERUP
        // ============================================================

        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'shield', 'tripleShot', 'rapidFire'
                this.radius = 15;
                this.life = 8;
                this.rotation = 0;
                this.vx = random(-0.5, 0.5);
                this.vy = random(-0.5, 0.5);
                this.spawnTime = Date.now();
            }

            update(dt) {
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.rotation += dt * 2;
                this.life -= dt;

                this.x = wrap(this.x, 0, canvas.width);
                this.y = wrap(this.y, 0, canvas.height);
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                const colors = {
                    shield: '#3b82f6',
                    tripleShot: '#f97316',
                    rapidFire: '#fbbf24',
                    magnet: '#a855f7',
                    slowMo: '#06b6d4',
                    bomb: '#ef4444'
                };

                const color = colors[this.type];

                // Spawn animation
                const spawnAge = (currentTime - this.spawnTime) / 1000;
                const spawnProgress = Math.min(1, spawnAge / 0.5);
                const spawnScale = spawnProgress;
                const spawnAlpha = spawnProgress;

                ctx.globalAlpha = spawnAlpha;
                ctx.scale(spawnScale, spawnScale);

                // Spawn ring effect
                if (spawnAge < 0.5) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = color;
                    const ringRadius = this.radius * (1 + (1 - spawnProgress) * 2);
                    ctx.globalAlpha = (1 - spawnProgress) * 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = spawnAlpha;
                }

                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20;
                ctx.shadowColor = color;

                if (this.type === 'shield') {
                    // Hexagon
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const x = Math.cos(angle) * this.radius;
                        const y = Math.sin(angle) * this.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.type === 'tripleShot') {
                    // Three arrows
                    [-0.3, 0, 0.3].forEach(offset => {
                        ctx.save();
                        ctx.rotate(offset);
                        ctx.beginPath();
                        ctx.moveTo(this.radius * 0.7, 0);
                        ctx.lineTo(-this.radius * 0.3, -this.radius * 0.4);
                        ctx.lineTo(-this.radius * 0.3, this.radius * 0.4);
                        ctx.closePath();
                        ctx.stroke();
                        ctx.restore();
                    });
                } else if (this.type === 'rapidFire') {
                    // Lightning bolt
                    ctx.beginPath();
                    ctx.moveTo(0, -this.radius);
                    ctx.lineTo(-this.radius * 0.3, 0);
                    ctx.lineTo(this.radius * 0.2, 0);
                    ctx.lineTo(0, this.radius);
                    ctx.lineTo(this.radius * 0.3, -this.radius * 0.3);
                    ctx.lineTo(-this.radius * 0.2, -this.radius * 0.3);
                    ctx.closePath();
                    ctx.stroke();
                } else if (this.type === 'magnet') {
                    // Horseshoe magnet
                    ctx.beginPath();
                    ctx.arc(0, -this.radius * 0.3, this.radius * 0.7, Math.PI, 0, false);
                    ctx.lineTo(this.radius * 0.7, this.radius);
                    ctx.moveTo(-this.radius * 0.7, -this.radius * 0.3);
                    ctx.lineTo(-this.radius * 0.7, this.radius);
                    ctx.stroke();
                } else if (this.type === 'slowMo') {
                    // Clock/stopwatch
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -this.radius * 0.6);
                    ctx.moveTo(0, 0);
                    ctx.lineTo(this.radius * 0.4, 0);
                    ctx.stroke();
                } else if (this.type === 'bomb') {
                    // Bomb with fuse
                    ctx.beginPath();
                    ctx.arc(0, this.radius * 0.2, this.radius * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, -this.radius * 0.6);
                    ctx.lineTo(0, -this.radius);
                    ctx.stroke();
                    // Sparkle on fuse
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(0, -this.radius, this.radius * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // ============================================================
        // BACKGROUND
        // ============================================================

        function initStars() {
            stars = [];
            for (let i = 0; i < 150; i++) {
                stars.push({
                    x: random(0, canvas.width),
                    y: random(0, canvas.height),
                    radius: random(0.5, 2),
                    brightness: random(0.3, 1),
                    layer: randomInt(0, 2),
                    twinkleSpeed: random(1, 3)
                });
            }
        }

        function drawStaticBackground() {
            // Performance: Render static stars to background canvas (called once or when needed)
            bgCtx.fillStyle = '#0a0e27';
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);

            // Draw stars (static, only update twinkle periodically)
            stars.forEach(star => {
                const twinkle = Math.sin(currentTime / 1000 * star.twinkleSpeed) * 0.3 + 0.7;
                bgCtx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkle})`;
                bgCtx.beginPath();
                bgCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                bgCtx.fill();
            });
            bgNeedsRedraw = false;
        }

        function drawBackground() {
            // Performance: Draw pre-rendered background (fast!)
            if (bgNeedsRedraw) {
                drawStaticBackground();
            }
            ctx.drawImage(bgCanvas, 0, 0);

            // Draw dynamic shooting stars on main canvas
            shootingStars.forEach((star, index) => {
                ctx.strokeStyle = `rgba(255, 255, 255, ${star.alpha})`;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(star.x, star.y);
                ctx.lineTo(star.x - star.vx * 20, star.y - star.vy * 20);
                ctx.stroke();

                star.x += star.vx;
                star.y += star.vy;
                star.life -= 0.016;
                star.alpha = star.life;

                if (star.life <= 0) {
                    shootingStars.splice(index, 1);
                }
            });
        }

        function updateShootingStars() {
            if (currentTime > nextShootingStarTime) {
                const edge = randomInt(0, 1);
                const x = edge === 0 ? random(0, canvas.width) : 0;
                const y = edge === 0 ? 0 : random(0, canvas.height);
                const angle = random(Math.PI / 6, Math.PI / 3);
                const speed = random(8, 12);

                shootingStars.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    alpha: 1
                });

                nextShootingStarTime = currentTime + random(10000, 20000);
            }
        }

        // ============================================================
        // COLLISION DETECTION
        // ============================================================

        function checkCollision(obj1, obj2) {
            return distance(obj1.x, obj1.y, obj2.x, obj2.y) < obj1.radius + obj2.radius;
        }

        function handleCollisions() {
            const bulletsToRemove = new Set();
            const asteroidsToRemove = new Set();
            const newAsteroidsToAdd = [];
            const ufoBulletsToRemove = new Set();
            const powerupsToRemove = new Set();

            // Bullets vs Asteroids
            for (let bIndex = 0; bIndex < bullets.length; bIndex++) {
                if (bulletsToRemove.has(bIndex)) continue;

                for (let aIndex = 0; aIndex < asteroids.length; aIndex++) {
                    if (asteroidsToRemove.has(aIndex)) continue;

                    if (checkCollision(bullets[bIndex], asteroids[aIndex])) {
                        // Hit!
                        shotsHit++;
                        const asteroid = asteroids[aIndex];
                        const points = asteroid.getPoints() * comboMultiplier;
                        score += points;
                        addScorePopup(asteroid.x, asteroid.y, points);
                        updateCombo();

                        // Create explosion
                        const particleCount = asteroid.size === 'large' ? 30 : asteroid.size === 'medium' ? 20 : 15;
                        createExplosion(asteroid.x, asteroid.y, particleCount, ['#6b7280', '#9ca3af', '#d1d5db']);

                        // Impact sparks at collision point
                        const impactAngle = Math.atan2(asteroid.y - bullets[bIndex].y, asteroid.x - bullets[bIndex].x);
                        createImpactSparks(bullets[bIndex].x, bullets[bIndex].y, impactAngle, 8);

                        // Play sound
                        playSound(`asteroid${asteroid.size.charAt(0).toUpperCase() + asteroid.size.slice(1)}`);

                        // Screen shake
                        if (asteroid.size === 'large') addScreenShake(4, 0.2);

                        // Split asteroid
                        const newAsteroids = asteroid.split();
                        newAsteroidsToAdd.push(...newAsteroids);

                        // Mark for removal
                        asteroidsToRemove.add(aIndex);
                        bulletsToRemove.add(bIndex);

                        asteroidsDestroyed++;
                        break; // Bullet can only hit one asteroid
                    }
                }
            }

            // Bullets vs UFO
            if (ufo) {
                for (let bIndex = 0; bIndex < bullets.length; bIndex++) {
                    if (bulletsToRemove.has(bIndex)) continue;

                    if (checkCollision(bullets[bIndex], ufo)) {
                        shotsHit++;
                        const points = ufo.getPoints() * comboMultiplier;
                        score += points;
                        addScorePopup(ufo.x, ufo.y, points);
                        updateCombo();

                        // Explosion
                        createExplosion(ufo.x, ufo.y, 40, ['#ff3366', '#ff9933', '#00ff41'], 1.5);
                        playSound('ufoDestroy');
                        addScreenShake(5, 0.25);
                        addBorderGlow('#ff3366', 1.5, 0.8);

                        // Maybe drop powerup
                        if (Math.random() < selectedDifficulty.powerupChance) {
                            const types = ['shield', 'tripleShot', 'rapidFire', 'magnet', 'slowMo', 'bomb'];
                            const type = types[randomInt(0, types.length - 1)];
                            powerups.push(new Powerup(ufo.x, ufo.y, type));
                        }

                        bulletsToRemove.add(bIndex);
                        ufo = null;
                        ufosDestroyed++;
                        break;
                    }
                }
            }

            // Ship vs Asteroids
            if (ship && !ship.invulnerable) {
                for (let aIndex = 0; aIndex < asteroids.length; aIndex++) {
                    if (checkCollision(ship, asteroids[aIndex])) {
                        handleShipHit();
                        break; // Only process one collision per frame
                    }
                }
            }

            // Ship vs UFO
            if (ship && !ship.invulnerable && ufo) {
                if (checkCollision(ship, ufo)) {
                    handleShipHit();
                }
            }

            // Ship vs UFO bullets
            if (ship && !ship.invulnerable) {
                for (let index = 0; index < ufoBullets.length; index++) {
                    if (checkCollision(ship, ufoBullets[index])) {
                        handleShipHit();
                        ufoBulletsToRemove.add(index);
                        break; // Only process one collision per frame
                    }
                }
            }

            // Ship vs Powerups
            if (ship) {
                for (let index = 0; index < powerups.length; index++) {
                    const powerup = powerups[index];
                    if (checkCollision(ship, powerup)) {
                        playSound('powerup');
                        const colors = { shield: '#3b82f6', tripleShot: '#f97316', rapidFire: '#fbbf24', magnet: '#a855f7', slowMo: '#06b6d4', bomb: '#ef4444' };
                        const color = colors[powerup.type] || '#ffffff';
                        addFlash(color, 0.3);
                        createExplosion(powerup.x, powerup.y, 20, [color]);

                        if (powerup.type === 'shield') {
                            activePowerups.shield = true;
                        } else if (powerup.type === 'tripleShot') {
                            activePowerups.tripleShot.active = true;
                            activePowerups.tripleShot.timer = 10;
                        } else if (powerup.type === 'rapidFire') {
                            activePowerups.rapidFire.active = true;
                            activePowerups.rapidFire.timer = 10;
                        } else if (powerup.type === 'magnet') {
                            activePowerups.magnet.active = true;
                            activePowerups.magnet.timer = 10;
                        } else if (powerup.type === 'slowMo') {
                            activePowerups.slowMo.active = true;
                            activePowerups.slowMo.timer = 8;
                            timeScale = 0.5; // Slow down time
                        } else if (powerup.type === 'bomb') {
                            // Destroy all asteroids!
                            asteroids.forEach((asteroid, idx) => {
                                const points = asteroid.getPoints() * comboMultiplier;
                                score += points;
                                addScorePopup(asteroid.x, asteroid.y, points);
                                createExplosion(asteroid.x, asteroid.y, 15, ['#ef4444', '#ff9933']);
                            });
                            asteroids = [];
                            addScreenShake(10, 0.5);
                            addBorderGlow('#ef4444', 2, 1);
                            unlockAchievement('bomberman');
                        }

                        powerupsCollected++;
                        powerupsToRemove.add(index);
                    }
                }
            }

            // Remove marked items (iterate backwards to maintain correct indices)
            const bulletIndices = Array.from(bulletsToRemove).sort((a, b) => b - a);
            bulletIndices.forEach(index => bullets.splice(index, 1));

            const asteroidIndices = Array.from(asteroidsToRemove).sort((a, b) => b - a);
            asteroidIndices.forEach(index => asteroids.splice(index, 1));

            const ufoBulletIndices = Array.from(ufoBulletsToRemove).sort((a, b) => b - a);
            ufoBulletIndices.forEach(index => ufoBullets.splice(index, 1));

            const powerupIndices = Array.from(powerupsToRemove).sort((a, b) => b - a);
            powerupIndices.forEach(index => powerups.splice(index, 1));

            // Add new asteroids after all removal is done (with limit)
            const availableSlots = MAX_ASTEROIDS - asteroids.length;
            const asteroidsToAdd = newAsteroidsToAdd.slice(0, availableSlots);
            asteroids.push(...asteroidsToAdd);
        }

        function handleShipHit() {
            if (activePowerups.shield) {
                // Shield absorbs hit
                activePowerups.shield = false;
                addFlash('#3b82f6', 0.5);
                playSound('asteroidSmall');
                createExplosion(ship.x, ship.y, 20, ['#3b82f6']);
            } else {
                // Ship destroyed
                lives--;
                score = Math.max(0, score - 500);

                createExplosion(ship.x, ship.y, 50, ['#ffffff', '#ff9933', '#ff6633', '#ff3366'], 2);
                playSound('death');
                addScreenShake(8, 0.4);
                addFlash('#ffffff', 0.7);

                if (lives <= 0) {
                    gameState = GAME_STATE.GAME_OVER;
                    if (score > highScore) {
                        highScore = score;
                        localStorage.setItem('asteroidsHighScore', highScore);
                    }
                } else {
                    ship = null;
                    setTimeout(() => {
                        if (gameState === GAME_STATE.PLAYING) {
                            respawnShip();
                        }
                    }, 2000);
                }
            }
        }

        function respawnShip(attempts = 0) {
            // Prevent infinite recursion - after 20 attempts (10 seconds), force spawn
            const MAX_ATTEMPTS = 20;

            // Check if spawn area is clear
            const spawnX = canvas.width / 2;
            const spawnY = canvas.height / 2;
            const clearRadius = 100;

            let canSpawn = true;
            if (attempts < MAX_ATTEMPTS) {
                asteroids.forEach(asteroid => {
                    if (distance(spawnX, spawnY, asteroid.x, asteroid.y) < clearRadius + asteroid.radius) {
                        canSpawn = false;
                    }
                });
            }

            if (canSpawn || attempts >= MAX_ATTEMPTS) {
                ship = new Ship();
            } else {
                setTimeout(() => respawnShip(attempts + 1), 500);
            }
        }

        // ============================================================
        // COMBO SYSTEM
        // ============================================================

        function updateCombo() {
            const now = currentTime;

            if (now - lastKillTime < 3000) {
                comboCount++;
                comboMultiplier = Math.min(10, comboCount);
                playSound('combo');
                addFlash(comboMultiplier > 5 ? '#ff00ff' : '#00ffff', 0.2);

                // Border glow for high combos
                if (comboMultiplier >= 5) {
                    const glowColor = comboMultiplier <= 7 ? '#ff00ff' : '#ff0000';
                    addBorderGlow(glowColor, comboMultiplier / 5, 0.4);
                }
            } else {
                comboCount = 1;
                comboMultiplier = 1;
            }

            lastKillTime = now;
            comboTimer = 3;
        }

        // ============================================================
        // WAVE SYSTEM
        // ============================================================

        function startWave(waveNumber) {
            asteroids = [];

            // Determine wave type (every 5th wave is special, 3rd is bonus)
            if (waveNumber % 5 === 0) {
                currentWaveType = 'titans';
            } else if (waveNumber % 3 === 0) {
                currentWaveType = 'storm';
            } else {
                currentWaveType = 'normal';
            }

            // Aggressive optimization: cap at 6 large asteroids per wave
            let baseCount = 3;
            if (waveNumber >= 2 && waveNumber <= 5) {
                baseCount = 3 + (waveNumber - 1);
            } else if (waveNumber >= 6) {
                baseCount = 6; // Capped at 6 for performance
            }

            if (currentWaveType === 'storm') {
                // Asteroid Storm: Many small asteroids
                for (let i = 0; i < Math.min(20, baseCount * 3); i++) {
                    let x, y;
                    do {
                        x = random(0, canvas.width);
                        y = random(0, canvas.height);
                    } while (distance(x, y, canvas.width / 2, canvas.height / 2) < 150);
                    asteroids.push(new Asteroid(x, y, 'small'));
                }
            } else if (currentWaveType === 'titans') {
                // Titans: Few large asteroids only
                for (let i = 0; i < Math.min(4, baseCount); i++) {
                    let x, y;
                    do {
                        x = random(0, canvas.width);
                        y = random(0, canvas.height);
                    } while (distance(x, y, canvas.width / 2, canvas.height / 2) < 150);
                    asteroids.push(new Asteroid(x, y, 'large'));
                }
            } else {
                // Normal: Regular mix
                for (let i = 0; i < baseCount; i++) {
                    let x, y;
                    do {
                        x = random(0, canvas.width);
                        y = random(0, canvas.height);
                    } while (distance(x, y, canvas.width / 2, canvas.height / 2) < 150);
                    asteroids.push(new Asteroid(x, y, 'large'));
                }
            }

            // Reset UFO timer
            ufoSpawnTimer = 0;
            nextUfoSpawnTime = random(selectedDifficulty.ufoSpawnMin, selectedDifficulty.ufoSpawnMax);
        }

        function checkWaveComplete() {
            if (asteroids.length === 0 && gameState === GAME_STATE.PLAYING) {
                // Wave complete!
                const waveBonus = wave * 500;
                score += waveBonus;

                gameState = GAME_STATE.WAVE_TRANSITION;
                waveTransitionTimer = 3;
                waveTransitionMessage = `WAVE ${wave} COMPLETE!\n+${waveBonus} BONUS`;

                // Border glow for wave completion
                addBorderGlow('#00ff41', 2, 1);

                setTimeout(() => {
                    wave++;

                    // Determine next wave type for preview
                    let nextWaveType = 'normal';
                    if (wave % 5 === 0) nextWaveType = 'titans';
                    else if (wave % 3 === 0) nextWaveType = 'storm';

                    const waveTypeNames = {
                        normal: '',
                        storm: '⚡ ASTEROID STORM',
                        titans: '💎 TITAN WAVE'
                    };

                    const typeName = waveTypeNames[nextWaveType];
                    waveTransitionMessage = `WAVE ${wave}${typeName ? '\n' + typeName : ''}`;
                    waveTransitionTimer = 2;

                    setTimeout(() => {
                        if (gameState === GAME_STATE.WAVE_TRANSITION) {
                            gameState = GAME_STATE.PLAYING;
                            startWave(wave);
                        }
                    }, 2000);
                }, 3000);
            }
        }

        // ============================================================
        // GAME INITIALIZATION
        // ============================================================

        function initGame() {
            initAudio();
            initStars();

            score = 0;
            lives = selectedDifficulty.lives;
            wave = 1;
            comboCount = 0;
            comboMultiplier = 1;
            lastKillTime = 0;
            shotsFired = 0;
            shotsHit = 0;
            asteroidsDestroyed = 0;
            ufosDestroyed = 0;
            powerupsCollected = 0;
            showTutorial = true;
            tutorialTimer = 4;

            ship = new Ship();
            asteroids = [];
            bullets = [];
            ufoBullets = [];
            ufo = null;
            powerups = [];
            scorePopups = [];

            // Reset particle pool instead of particles array
            particlePool.pool.forEach(p => p.active = false);

            activePowerups = {
                shield: false,
                tripleShot: { active: false, timer: 0 },
                rapidFire: { active: false, timer: 0 },
                magnet: { active: false, timer: 0 },
                slowMo: { active: false, timer: 0 }
            };
            timeScale = 1.0;

            startWave(1);
        }

        // ============================================================
        // UPDATE LOOP
        // ============================================================

        function update(dt) {
            if (gameState === GAME_STATE.PLAYING) {
                // Apply time scale for slow-mo (but keep ship at normal speed)
                const scaledDt = dt * timeScale;

                // Update ship (unaffected by slow-mo)
                if (ship) {
                    ship.update(dt);

                    // Shooting
                    if (keys[' '] && bullets.length < 5) {
                        ship.shoot();
                    }
                }

                // Update asteroids (with safety limit, affected by slow-mo)
                const MAX_ASTEROIDS = 100;
                if (asteroids.length > MAX_ASTEROIDS) {
                    console.warn('Too many asteroids, removing oldest');
                    asteroids.splice(0, asteroids.length - MAX_ASTEROIDS);
                }
                asteroids.forEach(asteroid => asteroid.update(scaledDt));

                // Update bullets (player bullets unaffected by slow-mo)
                bullets = bullets.filter(bullet => {
                    bullet.update(dt);
                    return bullet.life > 0;
                });

                // Update UFO bullets (with safety limit, affected by slow-mo)
                const MAX_UFO_BULLETS = 50;
                if (ufoBullets.length > MAX_UFO_BULLETS) {
                    console.warn('Too many UFO bullets, removing oldest');
                    ufoBullets.splice(0, ufoBullets.length - MAX_UFO_BULLETS);
                }
                ufoBullets = ufoBullets.filter(bullet => {
                    bullet.x += bullet.vx * scaledDt * 60;
                    bullet.y += bullet.vy * scaledDt * 60;
                    bullet.life -= scaledDt;

                    // Remove bullet if it goes off-screen
                    if (bullet.x < -10 || bullet.x > canvas.width + 10 ||
                        bullet.y < -10 || bullet.y > canvas.height + 10) {
                        return false;
                    }

                    return bullet.life > 0;
                });

                // Update UFO (affected by slow-mo)
                if (ufo) {
                    if (!ufo.update(scaledDt)) {
                        ufo = null;
                    }
                }

                // Spawn UFO
                ufoSpawnTimer += dt * 1000;
                if (ufoSpawnTimer >= nextUfoSpawnTime && !ufo) {
                    const isSmall = wave >= 3;
                    ufo = new UFO(isSmall);
                    ufoSpawnTimer = 0;
                    nextUfoSpawnTime = random(selectedDifficulty.ufoSpawnMin, selectedDifficulty.ufoSpawnMax);
                }

                // Update powerups
                powerups = powerups.filter(powerup => {
                    powerup.update(dt);
                    return powerup.life > 0;
                });

                // Update powerup timers
                if (activePowerups.tripleShot.active) {
                    activePowerups.tripleShot.timer -= dt;
                    if (activePowerups.tripleShot.timer <= 0) {
                        activePowerups.tripleShot.active = false;
                    }
                }
                if (activePowerups.rapidFire.active) {
                    activePowerups.rapidFire.timer -= dt;
                    if (activePowerups.rapidFire.timer <= 0) {
                        activePowerups.rapidFire.active = false;
                    }
                }
                if (activePowerups.magnet.active) {
                    activePowerups.magnet.timer -= dt;
                    if (activePowerups.magnet.timer <= 0) {
                        activePowerups.magnet.active = false;
                    }
                    // Magnet logic: attract powerups
                    powerups.forEach(powerup => {
                        const dx = ship.x - powerup.x;
                        const dy = ship.y - powerup.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 0 && dist < 300) {
                            const strength = 3 / dist;
                            powerup.vx += (dx / dist) * strength;
                            powerup.vy += (dy / dist) * strength;
                        }
                    });
                }
                if (activePowerups.slowMo.active) {
                    activePowerups.slowMo.timer -= dt;
                    if (activePowerups.slowMo.timer <= 0) {
                        activePowerups.slowMo.active = false;
                        timeScale = 1.0; // Return to normal speed
                    }
                }

                // Update combo timer
                if (comboTimer > 0) {
                    comboTimer -= dt;
                    if (comboTimer <= 0) {
                        comboCount = 0;
                        comboMultiplier = 1;
                    }
                }

                // Tutorial timer
                if (showTutorial) {
                    tutorialTimer -= dt;
                    if (tutorialTimer <= 0) {
                        showTutorial = false;
                    }
                }

                // Collisions (with error handling)
                try {
                    handleCollisions();
                } catch (error) {
                    console.error('Collision detection error:', error);
                }

                // Check achievements
                checkAchievements();

                // Check wave complete
                checkWaveComplete();
            }

            if (gameState === GAME_STATE.WAVE_TRANSITION) {
                waveTransitionTimer -= dt;
            }

            // Update particles (using object pool for performance)
            const activeParticles = particlePool.getActiveParticles();
            activeParticles.forEach(particle => particle.update(dt));

            // Update score popups (with safety limit)
            const MAX_SCORE_POPUPS = 50;
            if (scorePopups.length > MAX_SCORE_POPUPS) {
                scorePopups.splice(0, scorePopups.length - MAX_SCORE_POPUPS);
            }
            scorePopups = scorePopups.filter(popup => {
                popup.update(dt);
                return popup.life > 0;
            });

            // Update effects
            updateScreenShake(dt);
            updateFlash(dt);
            updateBorderGlow(dt);
            updateShootingStars();

            // Update impact sparks
            impactSparks = impactSparks.filter(spark => {
                spark.update(dt);
                return spark.life > 0;
            });

            // Update mute indicator fade
            if (muteIndicatorAlpha > 0) {
                muteIndicatorAlpha -= dt * 2;
            }

            // Update achievement popup
            if (achievementPopup && achievementPopup.timer > 0) {
                achievementPopup.timer -= dt;
                if (achievementPopup.timer <= 0) {
                    achievementPopup = null;
                }
            }

            // Performance: Update background periodically for star twinkle
            bgUpdateTimer += dt;
            if (bgUpdateTimer >= BG_UPDATE_INTERVAL) {
                bgNeedsRedraw = true;
                bgUpdateTimer = 0;
            }
        }

        // ============================================================
        // RENDER
        // ============================================================

        function draw() {
            // Clear
            ctx.fillStyle = '#0a0e27';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply screen shake
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);

            // Background
            drawBackground();

            // Game objects
            if (gameState === GAME_STATE.PLAYING || gameState === GAME_STATE.PAUSED || gameState === GAME_STATE.WAVE_TRANSITION) {
                // Draw particles first (from object pool)
                particlePool.getActiveParticles().forEach(particle => particle.draw());

                // Draw impact sparks
                impactSparks.forEach(spark => spark.draw());

                // Draw asteroids
                asteroids.forEach(asteroid => asteroid.draw());

                // Draw bullets
                bullets.forEach(bullet => bullet.draw());

                // Draw UFO bullets
                ctx.fillStyle = '#ff0033';
                ufoBullets.forEach(bullet => {
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw UFO
                if (ufo) ufo.draw();

                // Draw powerups
                powerups.forEach(powerup => powerup.draw());

                // Draw ship
                if (ship) ship.draw();

                // Draw screen wrap indicators
                if (ship) drawWrapIndicators();

                // Draw score popups
                scorePopups.forEach(popup => popup.draw());

                // Draw HUD
                drawHUD();
            }

            ctx.restore();

            // Flash effect (after shake restoration)
            if (flashEffect.active) {
                ctx.fillStyle = flashEffect.color;
                ctx.globalAlpha = flashEffect.alpha;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
            }

            // Border glow effect
            if (borderGlow.active && borderGlow.duration > 0) {
                const alpha = Math.min(0.8, borderGlow.intensity * (borderGlow.duration / 0.5));
                ctx.strokeStyle = borderGlow.color;
                ctx.lineWidth = 8;
                ctx.shadowBlur = 30;
                ctx.shadowColor = borderGlow.color;
                ctx.globalAlpha = alpha;
                ctx.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);
                ctx.globalAlpha = 1;
            }

            // Mute indicator
            if (muteIndicatorAlpha > 0) {
                ctx.save();
                ctx.globalAlpha = muteIndicatorAlpha;
                ctx.font = 'bold 24px Courier New';
                ctx.fillStyle = muted ? '#ff0000' : '#00ff41';
                ctx.textAlign = 'right';
                ctx.shadowBlur = 10;
                ctx.shadowColor = muted ? '#ff0000' : '#00ff41';
                ctx.fillText(muted ? '🔇 MUTED' : '🔊 SOUND ON', canvas.width - 20, 40);
                ctx.restore();
            }

            // Achievement popup
            if (achievementPopup && achievementPopup.timer > 0) {
                const alpha = Math.min(1, achievementPopup.timer > 3 ? (4 - achievementPopup.timer) : achievementPopup.timer);
                ctx.save();
                ctx.globalAlpha = alpha;

                const boxWidth = 400;
                const boxHeight = 80;
                const x = canvas.width / 2 - boxWidth / 2;
                const y = 100;

                // Background box
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(x, y, boxWidth, boxHeight);

                // Border
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, boxWidth, boxHeight);

                // Achievement unlocked text
                ctx.font = 'bold 18px Courier New';
                ctx.fillStyle = '#ffd700';
                ctx.textAlign = 'center';
                ctx.fillText('🏆 ACHIEVEMENT UNLOCKED', canvas.width / 2, y + 28);

                // Achievement name
                ctx.font = 'bold 22px Courier New';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(achievementPopup.name, canvas.width / 2, y + 52);

                // Achievement description
                ctx.font = '14px Courier New';
                ctx.fillStyle = '#cccccc';
                ctx.fillText(achievementPopup.desc, canvas.width / 2, y + 70);

                ctx.restore();
            }

            // UI screens
            if (gameState === GAME_STATE.START) {
                drawStartScreen();
            } else if (gameState === GAME_STATE.PAUSED) {
                drawPauseScreen();
            } else if (gameState === GAME_STATE.GAME_OVER) {
                drawGameOverScreen();
            } else if (gameState === GAME_STATE.WAVE_TRANSITION) {
                drawWaveTransition();
            } else if (gameState === GAME_STATE.HELP) {
                drawHelpScreen();
            }
        }

        function drawWrapIndicators() {
            const edgeThreshold = 100; // Show indicator when within this distance from edge
            const indicatorSize = 15;

            ctx.strokeStyle = '#00ff41';
            ctx.fillStyle = '#00ff41';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.6;

            // Left edge -> show on right
            if (ship.x < edgeThreshold) {
                const wrapX = canvas.width - 20;
                const y = ship.y;
                ctx.beginPath();
                ctx.moveTo(wrapX - indicatorSize, y - indicatorSize);
                ctx.lineTo(wrapX, y);
                ctx.lineTo(wrapX - indicatorSize, y + indicatorSize);
                ctx.stroke();
            }

            // Right edge -> show on left
            if (ship.x > canvas.width - edgeThreshold) {
                const wrapX = 20;
                const y = ship.y;
                ctx.beginPath();
                ctx.moveTo(wrapX + indicatorSize, y - indicatorSize);
                ctx.lineTo(wrapX, y);
                ctx.lineTo(wrapX + indicatorSize, y + indicatorSize);
                ctx.stroke();
            }

            // Top edge -> show on bottom
            if (ship.y < edgeThreshold) {
                const x = ship.x;
                const wrapY = canvas.height - 20;
                ctx.beginPath();
                ctx.moveTo(x - indicatorSize, wrapY - indicatorSize);
                ctx.lineTo(x, wrapY);
                ctx.lineTo(x + indicatorSize, wrapY - indicatorSize);
                ctx.stroke();
            }

            // Bottom edge -> show on top
            if (ship.y > canvas.height - edgeThreshold) {
                const x = ship.x;
                const wrapY = 20;
                ctx.beginPath();
                ctx.moveTo(x - indicatorSize, wrapY + indicatorSize);
                ctx.lineTo(x, wrapY);
                ctx.lineTo(x + indicatorSize, wrapY + indicatorSize);
                ctx.stroke();
            }

            ctx.globalAlpha = 1;
        }

        function drawHUD() {
            ctx.shadowBlur = 0;

            // Score (top-left)
            ctx.font = 'bold 28px Courier New';
            ctx.fillStyle = '#00ff41';
            ctx.textAlign = 'left';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ff41';
            ctx.fillText(`SCORE: ${score}`, 20, 40);

            // High score (below score)
            ctx.font = 'bold 16px Courier New';
            ctx.fillStyle = '#ffd700';
            ctx.shadowColor = '#ffd700';
            ctx.fillText(`HIGH: ${highScore}`, 20, 65);

            // Wave (top-center)
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#7209b7';
            ctx.fillText(`WAVE ${wave}`, canvas.width / 2, 40);

            // Lives (top-right)
            ctx.textAlign = 'right';
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Courier New';
            ctx.fillText('LIVES:', canvas.width - 100, 40);

            for (let i = 0; i < lives; i++) {
                const x = canvas.width - 80 + i * 25;
                const y = 30;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-Math.PI / 2);
                ctx.strokeStyle = '#00ff41';
                ctx.lineWidth = 1.5;
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#00ff41';
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.lineTo(-5, -4);
                ctx.lineTo(-3, 0);
                ctx.lineTo(-5, 4);
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }

            // Combo counter
            if (comboMultiplier > 1) {
                const comboColor = comboMultiplier <= 3 ? '#00ffff' : comboMultiplier <= 6 ? '#ff00ff' : '#ff0000';
                ctx.font = 'bold 32px Courier New';
                ctx.fillStyle = comboColor;
                ctx.textAlign = 'left';
                ctx.shadowBlur = 15;
                ctx.shadowColor = comboColor;
                ctx.fillText(`×${comboMultiplier} COMBO!`, 20, 110);
            }

            // Power-up indicators
            let powerupY = canvas.height - 30;
            if (activePowerups.shield) {
                ctx.font = 'bold 18px Courier New';
                ctx.fillStyle = '#3b82f6';
                ctx.textAlign = 'left';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#3b82f6';
                ctx.fillText('SHIELD ACTIVE', 20, powerupY);
                powerupY -= 25;
            }
            if (activePowerups.tripleShot.active) {
                ctx.font = 'bold 18px Courier New';
                ctx.fillStyle = '#f97316';
                ctx.textAlign = 'left';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#f97316';
                ctx.fillText(`TRIPLE SHOT: ${Math.ceil(activePowerups.tripleShot.timer)}s`, 20, powerupY);
                powerupY -= 25;
            }
            if (activePowerups.rapidFire.active) {
                ctx.font = 'bold 18px Courier New';
                ctx.fillStyle = '#fbbf24';
                ctx.textAlign = 'left';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#fbbf24';
                ctx.fillText(`RAPID FIRE: ${Math.ceil(activePowerups.rapidFire.timer)}s`, 20, powerupY);
            }

            // Tutorial
            if (showTutorial) {
                ctx.font = 'bold 24px Courier New';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#7209b7';
                ctx.globalAlpha = Math.min(1, tutorialTimer);
                ctx.fillText('Destroy asteroids! Watch for UFOs!', canvas.width / 2, canvas.height / 2 + 100);
                ctx.globalAlpha = 1;
            }

            ctx.shadowBlur = 0;
        }

        function drawStartScreen() {
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(10, 14, 39, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.font = 'bold 80px Courier New';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#7209b7';
            ctx.fillText('ASTEROIDS', canvas.width / 2, 120);

            // Tagline
            ctx.font = '20px Courier New';
            ctx.fillStyle = '#00d9ff';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00d9ff';
            ctx.fillText('Destroy asteroids • Dodge enemies • Survive', canvas.width / 2, 160);

            // High score
            if (highScore > 0) {
                ctx.font = 'bold 24px Courier New';
                ctx.fillStyle = '#ffd700';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ffd700';
                ctx.fillText(`HIGH SCORE: ${highScore}`, canvas.width / 2, 200);
            }

            // Difficulty selection
            ctx.font = 'bold 28px Courier New';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#7209b7';
            ctx.fillText('SELECT DIFFICULTY', canvas.width / 2, 260);

            const difficulties = [DIFFICULTY.EASY, DIFFICULTY.MEDIUM, DIFFICULTY.HARD];
            difficulties.forEach((diff, index) => {
                const y = 310 + index * 60;
                const isSelected = selectedDifficulty === diff;

                ctx.font = 'bold 24px Courier New';
                ctx.fillStyle = isSelected ? '#ff006e' : '#7209b7';
                ctx.shadowBlur = isSelected ? 15 : 10;
                ctx.shadowColor = isSelected ? '#ff006e' : '#7209b7';

                ctx.fillText(diff.name, canvas.width / 2, y);
            });

            // Start button
            ctx.font = 'bold 32px Courier New';
            ctx.fillStyle = '#00ff41';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ff41';
            ctx.fillText('PRESS ENTER TO START', canvas.width / 2, 500);

            // Controls
            ctx.font = '18px Courier New';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#7209b7';
            ctx.textAlign = 'left';
            const controlsX = canvas.width / 2 - 150;
            ctx.fillText('← →  : Rotate', controlsX, 560);
            ctx.fillText('↑    : Thrust', controlsX, 585);
            ctx.fillText('SPACE: Shoot', controlsX, 610);
            ctx.fillText('P    : Pause', controlsX, 635);
            ctx.fillText('M    : Mute', controlsX, 660);

            // Version number
            ctx.font = '14px Courier New';
            ctx.fillStyle = '#6b7280';
            ctx.textAlign = 'right';
            ctx.shadowBlur = 0;
            ctx.fillText(VERSION, canvas.width - 20, canvas.height - 20);

            ctx.shadowBlur = 0;
        }

        function drawPauseScreen() {
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(10, 14, 39, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = 'bold 60px Courier New';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#7209b7';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 50);

            ctx.font = '24px Courier New';
            ctx.fillStyle = '#00ff41';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ff41';
            ctx.fillText('Press P to resume', canvas.width / 2, canvas.height / 2 + 20);

            ctx.fillStyle = '#ff006e';
            ctx.shadowColor = '#ff006e';
            ctx.fillText('Press ESC to quit', canvas.width / 2, canvas.height / 2 + 60);

            ctx.font = '20px Courier New';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 5;
            ctx.shadowColor = '#7209b7';
            ctx.fillText(`Score: ${score} | Wave: ${wave}`, canvas.width / 2, canvas.height / 2 + 120);

            ctx.shadowBlur = 0;
        }

        function drawGameOverScreen() {
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(10, 14, 39, 0.9)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = 'bold 70px Courier New';
            ctx.fillStyle = '#ff006e';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 25;
            ctx.shadowColor = '#ff006e';
            ctx.fillText('GAME OVER', canvas.width / 2, 120);

            // New high score
            if (score === highScore && score > 0) {
                ctx.font = 'bold 32px Courier New';
                ctx.fillStyle = '#ffd700';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffd700';
                ctx.fillText('★ NEW HIGH SCORE! ★', canvas.width / 2, 170);
            }

            // Final score
            ctx.font = 'bold 40px Courier New';
            ctx.fillStyle = '#00ff41';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ff41';
            ctx.fillText(`FINAL SCORE: ${score}`, canvas.width / 2, 230);

            ctx.font = 'bold 28px Courier New';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#7209b7';
            ctx.fillText(`Wave Reached: ${wave}`, canvas.width / 2, 275);

            // Statistics
            ctx.font = '22px Courier New';
            ctx.fillStyle = '#00d9ff';
            ctx.shadowBlur = 8;
            ctx.shadowColor = '#00d9ff';

            const statsY = 330;
            ctx.fillText(`Asteroids Destroyed: ${asteroidsDestroyed}`, canvas.width / 2, statsY);
            ctx.fillText(`UFOs Destroyed: ${ufosDestroyed}`, canvas.width / 2, statsY + 35);

            const accuracy = shotsFired > 0 ? Math.round((shotsHit / shotsFired) * 100) : 0;
            ctx.fillText(`Accuracy: ${accuracy}%`, canvas.width / 2, statsY + 70);

            // Buttons
            ctx.font = 'bold 28px Courier New';
            ctx.fillStyle = '#00ff41';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#00ff41';
            ctx.fillText('Press ENTER to Play Again', canvas.width / 2, statsY + 150);

            ctx.fillStyle = '#7209b7';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#7209b7';
            ctx.fillText('Press ESC for Main Menu', canvas.width / 2, statsY + 190);

            ctx.shadowBlur = 0;
        }

        function drawHelpScreen() {
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(10, 14, 39, 0.95)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Title
            ctx.font = 'bold 48px Courier New';
            ctx.fillStyle = '#00ff41';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ff41';
            ctx.fillText('HELP', canvas.width / 2, 80);

            // Sections
            const leftCol = canvas.width / 2 - 280;
            const rightCol = canvas.width / 2 + 20;
            let y = 140;

            // Controls section
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = '#ff006e';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff006e';
            ctx.textAlign = 'left';
            ctx.fillText('CONTROLS', leftCol, y);

            ctx.font = '18px Courier New';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 5;
            y += 30;
            ctx.fillText('← →  : Rotate ship', leftCol, y);
            y += 25;
            ctx.fillText('↑    : Thrust', leftCol, y);
            y += 25;
            ctx.fillText('SPACE: Shoot', leftCol, y);
            y += 25;
            ctx.fillText('P    : Pause', leftCol, y);
            y += 25;
            ctx.fillText('M    : Mute', leftCol, y);
            y += 25;
            ctx.fillText('H    : Help', leftCol, y);

            // How to Play section
            y = 140;
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = '#ff006e';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff006e';
            ctx.fillText('HOW TO PLAY', rightCol, y);

            ctx.font = '16px Courier New';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 5;
            y += 30;
            ctx.fillText('• Destroy asteroids to earn points', rightCol, y);
            y += 22;
            ctx.fillText('• Watch for UFOs - they drop power-ups!', rightCol, y);
            y += 22;
            ctx.fillText('• Build combos (kill within 3s)', rightCol, y);
            y += 22;
            ctx.fillText('• Complete waves for bonuses', rightCol, y);
            y += 22;
            ctx.fillText('• Your ship wraps around the screen', rightCol, y);
            y += 22;
            ctx.fillText('• 3 lives per game', rightCol, y);

            // Power-ups section
            y += 50;
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = '#ff006e';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff006e';
            ctx.textAlign = 'left';
            ctx.fillText('POWER-UPS', leftCol, y);

            ctx.font = '18px Courier New';
            y += 30;
            ctx.fillStyle = '#3b82f6';
            ctx.shadowColor = '#3b82f6';
            ctx.fillText('🛡️  Shield', leftCol, y);
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 5;
            ctx.fillText(' - Absorbs one hit', leftCol + 100, y);

            y += 25;
            ctx.fillStyle = '#f97316';
            ctx.shadowColor = '#f97316';
            ctx.shadowBlur = 10;
            ctx.fillText('🔫 Triple Shot', leftCol, y);
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 5;
            ctx.fillText(' - Fire 3 bullets (10s)', leftCol + 150, y);

            y += 25;
            ctx.fillStyle = '#fbbf24';
            ctx.shadowColor = '#fbbf24';
            ctx.shadowBlur = 10;
            ctx.fillText('⚡ Rapid Fire', leftCol, y);
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 5;
            ctx.fillText(' - Faster shooting (10s)', leftCol + 150, y);

            // Scoring section
            y += 50;
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = '#ff006e';
            ctx.shadowColor = '#ff006e';
            ctx.shadowBlur = 10;
            ctx.fillText('SCORING', rightCol, y);

            ctx.font = '18px Courier New';
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 5;
            y += 30;
            ctx.fillText('Large asteroid:  20 pts', rightCol, y);
            y += 25;
            ctx.fillText('Medium asteroid: 50 pts', rightCol, y);
            y += 25;
            ctx.fillText('Small asteroid:  100 pts', rightCol, y);
            y += 25;
            ctx.fillText('Large UFO:       100 pts', rightCol, y);
            y += 25;
            ctx.fillText('Small UFO:       200 pts', rightCol, y);
            y += 25;
            ctx.fillText('Wave bonus:      Wave × 500', rightCol, y);
            y += 25;
            ctx.fillText('Combo multiplier: Up to 10x!', rightCol, y);

            // Tips section
            y += 50;
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = '#ff006e';
            ctx.shadowColor = '#ff006e';
            ctx.shadowBlur = 10;
            ctx.textAlign = 'center';
            ctx.fillText('TIPS FOR HIGH SCORES', canvas.width / 2, y);

            ctx.font = '16px Courier New';
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 5;
            y += 30;
            ctx.fillText('Master the combo system • Prioritize UFOs • Use power-ups strategically', canvas.width / 2, y);
            y += 20;
            ctx.fillText('Break large asteroids early • Keep moving • Practice makes perfect!', canvas.width / 2, y);

            // Footer
            ctx.font = '20px Courier New';
            ctx.fillStyle = '#7209b7';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#7209b7';
            ctx.fillText('Press ESC to return', canvas.width / 2, canvas.height - 30);

            // Version number
            ctx.font = '14px Courier New';
            ctx.fillStyle = '#6b7280';
            ctx.textAlign = 'right';
            ctx.shadowBlur = 0;
            ctx.fillText(VERSION, canvas.width - 20, canvas.height - 20);

            ctx.shadowBlur = 0;
        }

        function drawWaveTransition() {
            ctx.fillStyle = 'rgba(10, 14, 39, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = 'bold 48px Courier New';
            ctx.fillStyle = '#00ff41';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ff41';

            const lines = waveTransitionMessage.split('\n');
            lines.forEach((line, index) => {
                ctx.fillText(line, canvas.width / 2, canvas.height / 2 - 30 + index * 60);
            });

            ctx.shadowBlur = 0;
        }

        // ============================================================
        // INPUT HANDLING
        // ============================================================

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            // Prevent default for game keys
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ', 'p', 'P', 'Escape', 'Enter', 'm', 'M', 'h', 'H'].includes(e.key)) {
                e.preventDefault();
            }

            // Start screen
            if (gameState === GAME_STATE.START) {
                if (e.key === '1' || e.key.toLowerCase() === 'e') {
                    selectedDifficulty = DIFFICULTY.EASY;
                } else if (e.key === '2' || e.key.toLowerCase() === 'm') {
                    selectedDifficulty = DIFFICULTY.MEDIUM;
                } else if (e.key === '3' || e.key.toLowerCase() === 'h') {
                    selectedDifficulty = DIFFICULTY.HARD;
                } else if (e.key === 'ArrowUp') {
                    // Cycle up through difficulties
                    if (selectedDifficulty === DIFFICULTY.HARD) {
                        selectedDifficulty = DIFFICULTY.MEDIUM;
                    } else if (selectedDifficulty === DIFFICULTY.MEDIUM) {
                        selectedDifficulty = DIFFICULTY.EASY;
                    } else {
                        selectedDifficulty = DIFFICULTY.HARD;
                    }
                } else if (e.key === 'ArrowDown') {
                    // Cycle down through difficulties
                    if (selectedDifficulty === DIFFICULTY.EASY) {
                        selectedDifficulty = DIFFICULTY.MEDIUM;
                    } else if (selectedDifficulty === DIFFICULTY.MEDIUM) {
                        selectedDifficulty = DIFFICULTY.HARD;
                    } else {
                        selectedDifficulty = DIFFICULTY.EASY;
                    }
                } else if (e.key === 'Enter') {
                    gameState = GAME_STATE.PLAYING;
                    initGame();
                }
            }
            // Pause
            else if (gameState === GAME_STATE.PLAYING && (e.key === 'p' || e.key === 'P')) {
                gameState = GAME_STATE.PAUSED;
            }
            else if (gameState === GAME_STATE.PAUSED) {
                if (e.key === 'p' || e.key === 'P') {
                    gameState = GAME_STATE.PLAYING;
                } else if (e.key === 'Escape') {
                    gameState = GAME_STATE.START;
                }
            }
            // Game over
            else if (gameState === GAME_STATE.GAME_OVER) {
                if (e.key === 'Enter') {
                    gameState = GAME_STATE.PLAYING;
                    initGame();
                } else if (e.key === 'Escape') {
                    gameState = GAME_STATE.START;
                }
            }
            // Help screen
            else if (gameState === GAME_STATE.HELP) {
                if (e.key === 'Escape') {
                    gameState = previousGameState;
                }
            }

            // Help toggle (H key) - works from playing, paused, or game over
            if ((e.key === 'h' || e.key === 'H') && gameState !== GAME_STATE.START && gameState !== GAME_STATE.WAVE_TRANSITION) {
                if (gameState === GAME_STATE.HELP) {
                    gameState = previousGameState;
                } else {
                    previousGameState = gameState;
                    gameState = GAME_STATE.HELP;
                }
            }

            // Mute toggle
            if (e.key === 'm' || e.key === 'M') {
                muted = !muted;
                muteIndicatorAlpha = 1;
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Mouse controls
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Scale mouse coordinates to canvas internal coordinates
            mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
            mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
            const canvasY = (e.clientY - rect.top) * (canvas.height / rect.height);

            // Handle START screen difficulty selection
            if (gameState === GAME_STATE.START) {
                const centerX = canvas.width / 2;
                const buttonWidth = 200;
                const buttonHeight = 40;

                // Check difficulty buttons (y: 310, 370, 430)
                const difficulties = [DIFFICULTY.EASY, DIFFICULTY.MEDIUM, DIFFICULTY.HARD];
                difficulties.forEach((diff, index) => {
                    const buttonY = 310 + index * 60;
                    if (canvasX >= centerX - buttonWidth/2 && canvasX <= centerX + buttonWidth/2 &&
                        canvasY >= buttonY - buttonHeight/2 && canvasY <= buttonY + buttonHeight/2) {
                        selectedDifficulty = diff;
                    }
                });

                // Check START button (y: 500)
                const startButtonWidth = 400;
                const startButtonY = 500;
                if (canvasX >= centerX - startButtonWidth/2 && canvasX <= centerX + startButtonWidth/2 &&
                    canvasY >= startButtonY - buttonHeight/2 && canvasY <= startButtonY + buttonHeight/2) {
                    gameState = GAME_STATE.PLAYING;
                    initGame();
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            mouseDown = false;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Prevent right-click menu
        });

        // Touch controls for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const canvasX = (touch.clientX - rect.left) * (canvas.width / rect.width);
            const canvasY = (touch.clientY - rect.top) * (canvas.height / rect.height);

            // Handle START screen difficulty selection
            if (gameState === GAME_STATE.START) {
                const centerX = canvas.width / 2;
                const buttonWidth = 200;
                const buttonHeight = 40;

                // Check difficulty buttons (y: 310, 370, 430)
                const difficulties = [DIFFICULTY.EASY, DIFFICULTY.MEDIUM, DIFFICULTY.HARD];
                difficulties.forEach((diff, index) => {
                    const buttonY = 310 + index * 60;
                    if (canvasX >= centerX - buttonWidth/2 && canvasX <= centerX + buttonWidth/2 &&
                        canvasY >= buttonY - buttonHeight/2 && canvasY <= buttonY + buttonHeight/2) {
                        selectedDifficulty = diff;
                    }
                });

                // Check START button (y: 500)
                const startButtonWidth = 400;
                const startButtonY = 500;
                if (canvasX >= centerX - startButtonWidth/2 && canvasX <= centerX + startButtonWidth/2 &&
                    canvasY >= startButtonY - buttonHeight/2 && canvasY <= startButtonY + buttonHeight/2) {
                    gameState = GAME_STATE.PLAYING;
                    initGame();
                }
            }

            // Handle PLAYING state
            if (gameState === GAME_STATE.PLAYING) {
                touchX = canvasX;
                touchY = canvasY;
                touching = true;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (touching && gameState === GAME_STATE.PLAYING) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                // Scale touch coordinates to canvas internal coordinates
                touchX = (touch.clientX - rect.left) * (canvas.width / rect.width);
                touchY = (touch.clientY - rect.top) * (canvas.height / rect.height);
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touching = false;
        }, { passive: false });

        // Don't auto-enable mouse controls on mobile
        // Touch controls work independently through the 'touching' flag

        // ============================================================
        // GAME LOOP
        // ============================================================

        let lastTime = 0;

        function gameLoop(timestamp) {
            try {
                const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
                lastTime = timestamp;
                currentTime = Date.now(); // Cache time once per frame for animations

                update(dt);
                draw();
            } catch (error) {
                console.error('Game loop error:', error);
                // Continue running despite errors
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================================
        // START
        // ============================================================

        initStars();
        nextShootingStarTime = currentTime + random(5000, 10000);
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
